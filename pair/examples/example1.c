/**
 * @file example1.c
 * @brief Examples for the pair.h file
 * @details This will show an example on how to use the arraylist with the pair
 */

#include <stdio.h>
#include <stdlib.h>

// If wanted to use asserts:
// #define PAIR_USE_ASSERT 1
// If wanted to use the arraylist_ prefix:
// #define PAIR_USE_PREFIX
#include "pair.h"

#include "arraylist.h"

#define noop_dtor(ptr, alloc) ((void)0)

// dinamically allocate strings
static char *heap_alloc_from_str_lit(const char *src, struct Allocator *alloc) {
    size_t len = strlen(src);
    char *dup = alloc->malloc(len + 1, alloc->ctx);
    if (dup) {
        memcpy(dup, src, len + 1);
    }
    return dup;
}

// This is only needed because we are allocating strings on the heap
void char_ptr_deinit(char **p, struct Allocator *alloc) {
    if (p && *p) {
        alloc->free(*p, strlen(*p) + 1, alloc->ctx);
        *p = NULL;
    }
}

// The following PAIR_TYPE and PAIR_DECL may be declared on the header
PAIR_TYPE(char *, int, grades)
PAIR_DECL(char *, int, grades)

// PAIR_TYPE just defined a struct that hold two types, char * and int, with "grades" appended on the name
// struct pair_grades { char *first; int second; }

// This must always be on a .c file
PAIR_IMPL(char *, int, grades, char_ptr_deinit, noop_dtor)

// Or with the all in one macro, must be in a .c file
// PAIR()

// grades_deinit here is the function generated by the pair header
ARRAYLIST(struct pair_grades, grades_list, grades_deinit)

void insert_grade(struct arraylist_grades_list *grades_list, char *name, int grade, struct Allocator *alloc) {
    struct pair_grades *tmp = grades_list_emplace_back_slot(grades_list);
    // Test tmp here
    tmp->first = heap_alloc_from_str_lit(name, alloc);
    // Test first here
    tmp->second = grade;
}

bool sort_grades_desc(struct pair_grades *a, struct pair_grades *b) {
    return a->second > b->second;
}

bool sort_grades_name(struct pair_grades *a, struct pair_grades *b) {
    return strcmp(a->first, b->first) < 0;
}

void print_student_grades(struct arraylist_grades_list *grades_list, size_t index) {
    printf("%10s :%3d\n", grades_list->data[index].first, grades_list->data[index].second);
}

int main(void) {
    struct Allocator alloc = allocator_get_default();
    struct arraylist_grades_list student_grades = grades_list_init(alloc);

    struct pair_grades *tmp = grades_list_emplace_back_slot(&student_grades);
    tmp->first = heap_alloc_from_str_lit("Alice", &alloc);
    tmp->second = 86;

    tmp = grades_list_emplace_back_slot(&student_grades);
    tmp->first = heap_alloc_from_str_lit("Bob", &alloc);
    tmp->second = 98;

    // The constructor generated by pair header can also be used to assign directly:
    *grades_list_emplace_back_slot(&student_grades) = grades_init(heap_alloc_from_str_lit("Ian", &alloc), 10);
    *grades_list_emplace_back_slot(&student_grades) = grades_init(heap_alloc_from_str_lit("Ron", &alloc), 43);
    *grades_list_emplace_back_slot(&student_grades) = grades_init(heap_alloc_from_str_lit("Telos", &alloc), 69);

    // A function specific just for this
    insert_grade(&student_grades, "Ed", 67, &alloc);

    // Names could also be const static on read-only memory
    
    // without heap allocating strings here, an attempt to free invalid pointer on pair destructor will happen:
    // *grades_list_emplace_back_slot(&student_grades) = grades_init("test", 69); ///< error just because there is a destructor for char pointers
    
    // If all strings will be read-only on stack memory, then no destructor would be needed, but I am allocating memory for it

    insert_grade(&student_grades, "Amanda", 81, &alloc);
    insert_grade(&student_grades, "Marilyn", 63, &alloc);
    insert_grade(&student_grades, "Zane", 92, &alloc);
    insert_grade(&student_grades, "Jaden", 43, &alloc);
    
    grades_list_qsort(&student_grades, sort_grades_desc);
    
    for (size_t i = 0; i < student_grades.size; ++i) {
        print_student_grades(&student_grades, i);
    }

    puts("");

    grades_list_qsort(&student_grades, sort_grades_name);
    
    for (size_t i = 0; i < student_grades.size; ++i) {
        print_student_grades(&student_grades, i);
    }

    grades_list_deinit(&student_grades);

    return 0;
}